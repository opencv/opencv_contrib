#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/photometric_calib.hpp"

using namespace std;
using namespace cv;

int main()
{
    // Please down load the sample dataset from:
    // https://www.dropbox.com/s/5x48uhc7k2bgjcj/GSoC2017_PhotometricCalib_Sample_Data.zip?dl=0
    // By unzipping the file, you would get a folder named /GSoC2017_PhotometricCalib_Sample_Data which contains 2 subfolders:
    // response_calib, vignette_calib
    // in this sample, we will use the data in the folder vignette_calib

    // Prefix for the data, e.g. /Users/Yelen/GSoC2017_PhotometricCalib_Sample
    string userPrefix = "/Users/Yelen/GSoC2017_PhotometricCalib_Sample_Data/";
    // The path for the images used for response calibration
    string imageFolderPath = userPrefix + "vignette_calib/images";
    // The yaml file which contains the timestamps and exposure times for each image used for vignette calibration
    string timePath = userPrefix + "vignette_calib/times.yaml";
    // The yaml file which contains the camera intrinsics and extrinsics.
    // Note that the images are already rectified, so the distortion parameters are 0s
    string cameraPath = userPrefix + "vignette_calib/camera.yaml";
    // The pcalib file. Vignette calibration can be performed only when provided with pcalib file.
    // We use the identical pcalib.yaml file generated by response_calibration.cpp
    // You can refer to the code in response_calibration.cpp for details
    string gammaPath = userPrefix + "vignette_calib/pcalib.yaml";

    // Construct a photometric_calib::VignetteCalib object by giving path of image, path of time file, camera parameter file, pcalib file and specify the format of images
    photometric_calib::VignetteCalib vigCal(imageFolderPath, timePath, cameraPath, gammaPath, "jpg");

    // Debug mode will visualize the optimization process and generate some temporary data
    bool debug = true;
    // Calibration of camera response function begins
    vigCal.calib(debug);

    // You can also use fast mode, but with much memory (potentially with 10GB+)
    // vigCal.calibFast(debug);

    // The result and some intermediate data are stored in the folder ./vignetteCalibResult in which
    // vignette.png and vignetteSmoothed.png are the vignette images.
    // In practice, vignetteSomoothed.png is used, since it doesn't have the black boarders.
    Mat vigSmoothed = imread("./vignetteCalibResult/vignetteSmoothed.png", IMREAD_UNCHANGED);
    // As shown as Fig.4 in the paper from J.Engel, et al. in the paper A Photometrically Calibrated Benchmark For Monocular Visual Odometry
    namedWindow( "Vignette Smoothed", WINDOW_AUTOSIZE );
    imshow("Vignette Smoothed", vigSmoothed);

    // To see the vignette-calibrated image, we can use VignetteRemover
    Mat oriImg = imread(imageFolderPath + "/00480.jpg", IMREAD_UNCHANGED);
    photometric_calib::GammaRemover gammaRemover(gammaPath, oriImg.cols, oriImg.rows);
    photometric_calib::VignetteRemover vignetteRemover("./vignetteCalibResult/vignetteSmoothed.png", gammaPath, oriImg.cols, oriImg.rows);
    Mat resCaliImg = gammaRemover.getUnGammaImageMat(oriImg);
    Mat vigCaliImg = vignetteRemover.getUnVignetteImageMat(oriImg);

    // Visualization
    namedWindow( "Original Image", WINDOW_AUTOSIZE );
    imshow("Original Image", oriImg);
    namedWindow( "Gamma Removed Image", WINDOW_AUTOSIZE );
    imshow("Gamma Removed Image", resCaliImg);
    namedWindow( "Vignette Removed Image", WINDOW_AUTOSIZE );
    imshow("Vignette Removed Image", vigCaliImg);

    waitKey(0);

    return 0;
}